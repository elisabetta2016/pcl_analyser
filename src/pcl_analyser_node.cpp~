#include <ros/ros.h>
#include <ros/timer.h>
#include <math.h>
#include <iostream>
#include <string>
// PCL specific includes
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>

#include <pcl/filters/voxel_grid.h>
//#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/features/normal_3d.h>
#include <pcl/features/feature.h>
//#include <pcl/keypoints/sift_keypoint.h>
#include <pcl/common/projection_matrix.h>
//#include <pcl/features/pfhrgb.h>
#include <pcl/filters/filter.h> 

#include <pcl/PCLPointCloud2.h>
#include <pcl/conversions.h>
#include <pcl_ros/transforms.h>
#include <pcl/filters/statistical_outlier_removal.h>

#include <pcl/filters/project_inliers.h>

// Messages
#include <sensor_msgs/PointCloud2.h>

#include "donkey_rover/Rover_Track_Speed.h"
#include <geometry_msgs/Vector3.h>
#include <nav_msgs/Path.h>

// PCL keypoints headers

#include <pcl/common/transforms.h>
//Costmap

#include <costmap_2d/layer.h>
#include <costmap_2d/costmap_2d_ros.h>
#include <costmap_2d/costmap_2d_publisher.h>

// TF
#include <tf/transform_listener.h>
#include <Eigen/Dense> 

#define INFLATED_OBSTACLE 200
#define WIDTH 255 //default 
#include <vector>
#include "RoverPath.h"
using std::vector;
typedef pcl::PointXYZ PointXYZ;
typedef pcl::PointCloud<pcl::PointXYZ> PointCloudXYZ;

using namespace Eigen;
typedef pcl::PointXYZ PointType;

using costmap_2d::LETHAL_OBSTACLE;

/*
struct PATH_COST{
	float Lethal_cost;
	float Travel_cost;
	float Inf_cost;
	bool collision;	
};
struct CELL{
	unsigned int x;
	unsigned int y;
	unsigned char c;
};*/
struct PointIndex {
	int i;
	int j;
};

double lethal_rad = 0.1;
double inf_rad = 0.3;
double Travel_cost_inc = 0.0;
double Lethal_cost_inc = 10.0;
double Inf_cost_inc = 8.0;
double b = 0.8;
int sample = 15;

bool pso_analyse = false;
double pso_inertia;
double c_1;
double c_2;
double Goal_gain;
double Cost_gain;
double Speed_gain;

class ObstacleDetectorClass
{
	public:
		
	ObstacleDetectorClass(ros::NodeHandle& node)
	{
			n_=node;

			//subscribers
			SubFromCloud_		 = n_.subscribe("/RL_cloud", 1, &ObstacleDetectorClass::cloud_call_back,this);
			
			subFromTrackSpeed_	 = n_.subscribe("/RoverTrackSpeed", 1, &ObstacleDetectorClass::TrackCallback,this);
			subFromGoal_		 = n_.subscribe("/goal", 1, &ObstacleDetectorClass::GoalCallback,this);
			
			// publishers
			obstcle_pub_		  = n_.advertise<sensor_msgs::PointCloud2> ("obstacle_cloud", 1);
			obstcle_proj_pub_	  = n_.advertise<sensor_msgs::PointCloud2> ("obstacle_proj_cloud", 1);
			cost_map_cl_pub_	  = n_.advertise<sensor_msgs::PointCloud2> ("costmap_cloud", 1);
			path_trace_pub_        = n_.advertise<sensor_msgs::PointCloud2> ("path_trace", 1);
			
			repuslive_force_pub_	  = n_.advertise<geometry_msgs::Vector3> ("force", 1);
			path_pub_	  	  = n_.advertise<nav_msgs::Path> ("Path_sim", 1);
			path_solution_pub_        = n_.advertise<nav_msgs::Path> ("Path_pso", 1);
			

    			
    			// Range image params
    			
			support_size = 0.4f;
			setUnseenToMaxRange = false;
			
			//Initializer
			repulsive_force.x = 0.0;
			repulsive_force.y = 0.0;
			repulsive_force.z = 0.0;
			
			
			
			//obstacle avoidance params
			goal_present = false;
			
			
    			
	}
	
	void fill_costmap_test()
	{
		//ROS_INFO("fill costmap start  ");
		//pcl::PointCloud<pcl::PointXYZ>::Ptr fake_obs;
		pcl::PointCloud<pcl::PointXYZI> fake_obs_pc;
		
		float X_obs = 1.2;
		float Y_obs = -0.8;
		
		pcl::PointXYZI point;
		point.x = X_obs;
		point.y = Y_obs;
		point.z = 0.0;
		ROS_INFO("1");
		for(int i=0;i<3; i++)
		{
			ROS_INFO("2 loop");
			point.x = point.x + costmap_res;
			point.y = Y_obs;
			for(int j=0;j < 3;j++)
			{	
				
				point.y = point.y - costmap_res;
				point.z = 0.0;
				point.intensity = 255;
				fake_obs_pc.points.push_back(point);
				
			}
		}
		
		
		X_obs = 1.8;
		Y_obs = 1.8;
		point.x = X_obs;
		point.y = Y_obs;
		point.z = 0.0;
		for(int i=0;i<3; i++)
		{
			point.x = point.x + costmap_res;
			point.y = Y_obs;
			for(int j=0;j < 3;j++)
			{	
				
				point.y = point.y - costmap_res;
				point.z = 0.0;
				fake_obs_pc.points.push_back(point);
				
			}
		}
		
		cloud_to_costmap(fake_obs_pc, true);
		cost_map_2_cloud();
	
	
	}

	void cloud_voxel_filter(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out,float cube_size)
	{
		
  		pcl::VoxelGrid<pcl::PointXYZ> VG;
  		VG.setInputCloud (cloud_in);
  		VG.setLeafSize (cube_size, cube_size, cube_size);
 		VG.filter (*cloud_out);	
	
	}	

	void cloud_outlier_removal(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered)
	{
		pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
  		sor.setInputCloud (cloud_in);
  		sor.setMeanK (50);
  		sor.setStddevMulThresh (1.0);
  		sor.filter (*cloud_filtered);
	}
  	
  	void compute_repulsive_force(pcl::PointCloud<pcl::PointXYZ>::Ptr obs_proj)
  	{
  	
  	for (size_t i = 0; i < obs_proj->points.size (); ++i)
		{
			repulsive_force.x +=  1/obs_proj->points[i].x;
			repulsive_force.y +=  1/obs_proj->points[i].y;
			
		}

  	}

	
	void obstacle_find_Publish(const sensor_msgs::PointCloud2ConstPtr& cloud)
	{
	//ROS_INFO("Obstacle detection Starts!");
  	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_pcl (new pcl::PointCloud<pcl::PointXYZ>);
  	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_pcl (new pcl::PointCloud<pcl::PointXYZ>);
  	pcl::fromROSMsg(*cloud, *cloud_pcl);

 	*cloud_filtered_pcl = *cloud_pcl;

  
  
  
  	// Create the normal estimation class, and pass the input dataset to it
 	pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
  	ne.setInputCloud (cloud_pcl);
  	ne.setViewPoint(0,0,0.3);

  	// Create an empty kdtree representation, and pass it to the normal estimation object.
  	pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ> ());
  	ne.setSearchMethod (tree);

  	// normal datasets
  	pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);

  	// Use all neighbors in a sphere of radius 10cm
  	ne.setRadiusSearch (0.10);

  	// Compute the features
  	ne.compute (*cloud_normals);
  	//std::cout << cloud_normals->points.size() << "\n";
  
  
  	//Defining the Kdtree for finding the indicies
  	pcl::KdTreeFLANN<pcl::PointXYZ> kdtree;

  	kdtree.setInputCloud (cloud_pcl);
  	// Defining  the search point
  	pcl::PointXYZ searchPoint;

	// Starting to search and insert
	pcl::PointCloud<pcl::PointXYZ>::Ptr obstacle_pcl (new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZ> obstacle_nomal_pcl;
	pcl::PointCloud<pcl::PointXYZ>::Ptr obs_projected (new pcl::PointCloud<pcl::PointXYZ>);
	int K = 1;
	std::vector<int> pointIdxNKNSearch(K);
	std::vector<float> pointNKNSquaredDistance(K);
	
	obstacle_nomal_pcl = *cloud_filtered_pcl;

	for (size_t i = 0; i < cloud_filtered_pcl->points.size (); ++i)
	{
		searchPoint.x = cloud_filtered_pcl->points[i].x;
		searchPoint.y = cloud_filtered_pcl->points[i].y;
		searchPoint.z = cloud_filtered_pcl->points[i].z;
		
     		if ( kdtree.nearestKSearch (searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0 )
  		{
  	
  	
			for (size_t j = 0; j < pointIdxNKNSearch.size (); ++j)
			{

				//obstacle_nomal_pcl.points[pointIdxNKNSearch[j]].z = cloud_normals->points[pointIdxNKNSearch[j]].normal_z;
				
				
				if(cloud_normals->points[pointIdxNKNSearch[j]].normal_z < normal_threshold &&
			       		cloud_pcl->points[pointIdxNKNSearch[j]].z        > height_threshold &&
			       		cloud_pcl->points[pointIdxNKNSearch[j]].z        < height_max)
			       	{
			
					obstacle_pcl->points.push_back (cloud_pcl->points[ pointIdxNKNSearch[j] ]);
				}
			}		

		}
	
	}
	
	obstacle_pcl->width = int (obstacle_pcl->points.size ());
	obstacle_pcl->height = 1;
	obstacle_pcl->is_dense = true;
	
	//cloud_outlier_removal(obstacle_pcl,obstacle_pcl);
	
	pcl::toROSMsg(*obstacle_pcl,output_cloud);
	
    	output_cloud.header.frame_id = "laser";
    	output_cloud.header.stamp = ros::Time::now();	
    	
	//ROS_INFO("Nummber of points in obstacle_cloud is:");
	//std::cout << obstacle_pcl->points.size() << "\n";
	
	obstcle_pub_.publish(output_cloud);
	//ROS_WARN("Obstacle cloud published");
	cloud_2D_projection(obstacle_pcl,obs_projected);
	
	
	pcl::toROSMsg(*obs_projected,cloud_obstacle_projected);
    	cloud_obstacle_projected.header.frame_id = "laser";
    	cloud_obstacle_projected.header.stamp = ros::Time::now();		
	obstcle_proj_pub_.publish(cloud_obstacle_projected);
	
	//compute_repulsive_force(obs_projected);
	
	cloud_to_costmap(obstacle_pcl);
	cost_map_2_cloud();
	
	repuslive_force_pub_.publish(repulsive_force);
	repulsive_force.x = 0.0;
	repulsive_force.y = 0.0;
	repulsive_force.z = 0.0;
	//debug

	
	
	//debug end
	
	}
	
	void cloud_2D_projection(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out)
	{
	
	// Create a set of planar coefficients with X=Y=0,Z=1
	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients ());
	coefficients->values.resize (4);
	coefficients->values[0] = coefficients->values[1] = 0;
	coefficients->values[2] = 1.0;
	coefficients->values[3] = 0;

	// Create the filtering object
	pcl::ProjectInliers<pcl::PointXYZ> proj;
	proj.setModelType (pcl::SACMODEL_PLANE);
	proj.setInputCloud (cloud_in);
	proj.setModelCoefficients (coefficients);
	proj.filter (*cloud_out);
		
	}
	
	void cloud_call_back(const sensor_msgs::PointCloud2ConstPtr& cloud)
	{
		obstacle_find_Publish(cloud);
		
	
	}
	
	void cloud_to_costmap(pcl::PointCloud<pcl::PointXYZ>::Ptr obs_2d)
	{
	
	int mx;
	int my;

    	master_grid_->resetMap(0,0,cell_x-1,cell_y-1);
    
	for (size_t i = 0; i < obs_2d->points.size (); ++i)
	{
	
		master_grid_->worldToMapEnforceBounds((double) obs_2d->points[i].x,(double) obs_2d->points[i].y,mx,my);
		master_grid_ros->updateBounds(0,cell_x-1,0,cell_x-1);
		
		
		
		master_grid_->setCost(mx,my, LETHAL_OBSTACLE);
		
	
	
	}  
	
	lethal_inflation();	
  	// Costmap2DPublisher
  	master_grid_ros->publishCostmap();
  	
	}
	
	void cloud_to_costmap(pcl::PointCloud<pcl::PointXYZI> obs_2d, bool inflate)
	{
	
	int mx;
	int my;

    	master_grid_->resetMap(0,0,cell_x-1,cell_y-1);
    	unsigned char cost;
	for (size_t i = 0; i < obs_2d.points.size (); ++i)
	{
	
		master_grid_->worldToMapEnforceBounds((double) obs_2d.points[i].x,(double) obs_2d.points[i].y,mx,my);
		master_grid_ros->updateBounds(0,cell_x-1,0,cell_x-1);
		
		if (obs_2d.points[i].intensity == 200) cost = INFLATED_OBSTACLE;
		else cost = LETHAL_OBSTACLE;
		
		master_grid_->setCost(mx,my, cost);
		
	
	
	} 
	
	
  	// Costmap2DPublisher
  	if(inflate) lethal_inflation();
  	master_grid_ros->publishCostmap();
  	
	}
	
	
	void lethal_inflation() //fill the cell around the lethal obstacle
		{
			
	  		/*
					0 1 2 3 4 5 6 7 8 ...
				0	x
				1	y
			*/
			vector< vector<int> > matrix;
			matrix.resize(WIDTH);
			int index = -1;
			
			for (unsigned int i=0; i < cell_x ; i++) //loop in x
			{
				for (unsigned int j=0; j < cell_y ; j++) //loop in y
				{
					if(master_grid_->getCost(i,j) == LETHAL_OBSTACLE) //find the lethal obstacle
					{
						index++;
						matrix[index].resize(2);
						matrix[index][0] = i;
						matrix[index][1] = j;
						//list_x_lethal.push_back(i); //fill the list with lethal obstacles
						//list_y_lethal.push_back(j);
					}
				}
			}
		ROS_WARN("obstacle ist created successfully");	
			//loop in the list of lethal obstacles
			for (int k=0; k < index; k++) 
			{
				int cell_around = (int) floor(fabs(lethal_rad/costmap_res))+1;
				int i = matrix[k][0]; //x
				int j = matrix[k][1]; //y
				
				for (int ii=-cell_around; ii<cell_around+1; ii++) //loop around the obstacle
				{
					for (int jj=-cell_around; jj<cell_around+1; jj++) 
					{
					
						if ((i+ii) < 0) ii = std::min(-i,ii);
				        	if ((j+jj) < 0) jj = std::min(-j,jj);
						try
						
						{ 
				
						master_grid_->setCost(i+ii, j+jj, LETHAL_OBSTACLE); //fill the cell around the obstacle
						inf_inflation(i+ii,j+jj, master_grid_);
						
						}
				
						//continue even if exit from the grid
				
						catch(int e)	
			
						{
						//do nothing
						}
					}
				}
				
				
			
			}			
		}		
		
	void inf_inflation(int i,int j, costmap_2d::Costmap2D* grid)
	{
		
		
		int cell_around = (int) floor(fabs(inf_rad/costmap_res))+1;
		unsigned char INFLATION_OBSTACLE = 200;
			for (int k=-cell_around; k<cell_around+1; k++) //loop around the lethal obstacle
			{
			
				for (int l=-cell_around; l<cell_around+1; l++) 
				{
					
					if ((i+k) < 0) k = std::min(-i,k);
					if ((i+l) < 0) l = std::min(-j,l);
					unsigned char cost = grid->getCost((unsigned int)k+i,(unsigned int)l+j);
					//std::cout << "the cost is " << cost << std::endl;
					
					if(cost != LETHAL_OBSTACLE) //if is a lethal do nothing
					{
						try {
						     grid->setCost((unsigned int)i+k, (unsigned int)j+l, INFLATION_OBSTACLE); //fill the cell around lethal_obs
						}
						catch(int e)
						{
						//do nothing
						}
					}
				}
			}
	}	
		
	
	void cost_map_2_cloud()
	{
	double temp_x;
	double temp_y;
	cost_map_cloud.clear();
	for (size_t i=0; i < cell_x + 1; i++)
	  {
		for (size_t j=0; j < cell_y + 1; j++)
		{
			unsigned char cost = master_grid_->getCost(i,j);
			if(cost == LETHAL_OBSTACLE || cost == INFLATED_OBSTACLE) 
			{
				master_grid_->mapToWorld(i,j,temp_x,temp_y);

				
				pcl::PointXYZI point;
				point.z = 0.0;
				point.x = temp_x;
				point.y = temp_y;
				point.intensity = (float) cost; 			
				cost_map_cloud.points.push_back(point);
				
			}
		
		}
	   }
	
	}
	
  	
 	  	
	void GoalCallback(const geometry_msgs::Vector3::ConstPtr& msg)
	{
		nav_goal(0,0) = msg->x;
		nav_goal(0,1) = msg->y;
		nav_goal(0,2) = 0.0; 
		goal_present = true; 
	}
	
	void TrackCallback(const donkey_rover::Rover_Track_Speed::ConstPtr& msg)
	{
		ROS_INFO("Empty");
	}
		
	void testCallBack()
	{
		// inputs
		ROS_INFO_ONCE("Test Start");
		
  		float V_in = 1.0;
  		float Omega_in = -0.05;
  		VectorXf V_input;
  		VectorXf Omega_input;
  		Vector2f V_curr_c;
  		V_curr_c(0) = V_in;
  		V_curr_c(1) = Omega_in;
  		
  		V_input.setOnes(sample);
  		Omega_input.setOnes(sample);
  		V_input = V_in * V_input;
  		Omega_input = Omega_in * Omega_input;
  		
  		double Ts = 3.0;
  		Vector3f x_0;
  		x_0 << 0.0, 0.0, 0.0;
  		Vector3f x_dot_0;
  		x_dot_0 << 0.0, 0.0, 0.0;
  		
  		//outputs
  		Vector3f x_dot_f;
  		MatrixXf x;
  		x.setZero(3,sample);
		//Defining the instant of RoverPathClass
		int sample_ = sample;
		double b_ = b;
  		RoverPathClass RoverSim(b_,sample_,master_grid_);
		
  		//invoke

  		//x = RoverSim.Rover_vw(V_input, Omega_input, b, Ts,x_0,x_dot_0 , sample_, x_dot_f);
  		//ROS_WARN_STREAM_ONCE("trajectory is " << x);
  	//ROS_INFO("trajectory length:%d   x_mid:%f", x.cols(), x(0,sample-8));
  /*
  	//std::cout << x.cols() << "\n";
  		PATH_COST cost = Cost_of_path(x, master_grid_);
  		ROS_WARN_ONCE("lethal cost = %f",cost.Lethal_cost);
  		//ROS_WARN("lethal cost:%f, collision:%d", cost.Lethal_cost,cost.collision);
  		
  		if (cost.collision || (cost.Lethal_cost > 0.0))
  		{
  		// some logic to be implemented and the best path to be find by the method
  			if (!goal_present)
  			{
  				//ROS_INFO("trajectory");
  				//std::cout << x << std::endl;
  				nav_goal(0) = x(0,x.cols()-1);
  				nav_goal(1) = x(1,x.cols()-1);
  				nav_goal(2) = 0.0;
  			}
  			float D = 2.0;
  			
  			Vector2f output;
  			MatrixXf output_tra;
  			bool solution_found;
  			if (!pso_analyse)
  			{
  				output_tra = PSO_path_finder(nav_goal, D, V_curr_c, particle_no, iteration, output, solution_found);
				pso_analyse = true;  			
  			}
  			
  		}*/		
	  	
  	}
	
	
	
	void run()
	{
	
		double normal_threshold_default = 0.7;
		double height_threshold_default = -0.1;
		double height_max_default = 2.0;
		
		
		ros::NodeHandle n_pr("~");
	
		n_pr.param("normal_threshold", normal_threshold, normal_threshold_default);
		n_pr.param("height_threshold", height_threshold, height_threshold_default);
		n_pr.param("height_max", height_max,height_max_default);
		
		if (normal_threshold != normal_threshold_default) ROS_INFO_ONCE("normal threshold is changed to %f", normal_threshold);
		if (height_threshold != height_threshold_default) ROS_INFO_ONCE("height threshold is changed to %f", height_threshold);
		if (height_max       != height_max_default)       ROS_INFO_ONCE("height threshold is changed to %f", height_max);
		
		n_pr.param("costmap_res", costmap_res, 0.2);
		n_pr.param("LETHAL_radius", lethal_rad, 0.1);
		n_pr.param("INFLATION_radius", inf_rad, 0.3);
		
		n_pr.param("pso_inertia", pso_inertia, 0.1);
		n_pr.param("pso_c1", c_1, 0.45);
		n_pr.param("pso_c2", c_2, 0.45);
		n_pr.param("pso_goal_gain", Goal_gain, 30.0);
		n_pr.param("pso_cost_gain", Cost_gain, 1.0);
		n_pr.param("pso_speed_gain", Speed_gain, 0.0);
		n_pr.param("pso_particle_no", particle_no, 10);
		n_pr.param("pso_iteration", iteration, 5);
		
		n_pr.param("Travel_cost_inc", Travel_cost_inc, 0.0);
		n_pr.param("Lethal_cost_inc", Lethal_cost_inc, 10.0);
		n_pr.param("Inflation_cost_inc", Inf_cost_inc, 3.0);
		n_pr.param("b", b, 0.8);
		n_pr.param("sample", sample, 15);
		n_pr.param("demo_mode", demo_, false);
		
		ROS_INFO_ONCE("PSO Params: pso_inertia:%f, c1:%f, c2:%f, Number of Particle:%d, Iteration:%d",pso_inertia,c_1,c_2,particle_no,iteration);
		ROS_INFO_ONCE("PSO cost function Params: Goal_gain:%f, path_cost_gain:%f, speed_gain:%f",Goal_gain,Cost_gain,Speed_gain);
	
		ros::Rate rate(10.0);
		tf::TransformListener listener;
		
		
		//costmap params
		
			costmap_x_size = 6.0; // meters
			costmap_y_size = 6.0; // meters
			//costmap_res = 0.2;    // meters/cell
			
			cell_x = (unsigned int) floor(abs(costmap_x_size/costmap_res)); //cell
			cell_y = (unsigned int) floor(abs(costmap_y_size/costmap_res)); //cell
			
			master_grid_ = new costmap_2d::Costmap2D(cell_x,cell_y,costmap_res,-1.0,-3.0,0);
			n = &n_;
    			
    			global_frame = "laser";
			topic_name = "/global_costmap";
			
			master_grid_ros = new costmap_2d::Costmap2DPublisher(n,master_grid_,global_frame,topic_name,false);
		//costmap end
		
		
		
		bool first_loop = true;
		bool transform_present = true; 
		float curr_x;
		float curr_y;
		float curr_yaw;
		float last_x;
		float last_y;
		float last_yaw;		
		
		

		Matrix4f transform_1 = Matrix4f::Identity();
		int count = 0;
		
		//Vitual obstacle only for test
		fill_costmap_test(); 
		
		
		
		while(ros::ok())
		{
			
			
		    	tf::StampedTransform transform_odom_laser;
    		    	try{
      				listener.lookupTransform("/odom", "/laser", ros::Time(0), transform_odom_laser);
      				transform_present = true;
    		    	}
    			catch (tf::TransformException ex)
    			{
      				ROS_ERROR("%s",ex.what());
      				ros::Duration(0.05).sleep();
      				transform_present = false;
    			}
			//Reading x and y
			curr_x =transform_odom_laser.getOrigin().x();
			curr_y =transform_odom_laser.getOrigin().y();
			
			tfScalar roll,pitch,yaw;
			
			tf::Matrix3x3 M(transform_odom_laser.getRotation());
			M.getRPY(roll,pitch,yaw,(unsigned int) 1);
			curr_yaw = (float) yaw;
			
			
			if (!first_loop)
			{	
				
				float delta_x   = (curr_x - last_x);
				float delta_y   = (curr_y - last_y);
				float delta_yaw = (curr_yaw - last_yaw);
				

				/*
				| cos(yaw)  sin(yaw) 0  x|
				|-sin(yaw)  cos(yaw) 0  y|
				|     0        0     1  0|
				|     0        0     0  1|
				*/
				
				transform_1 (0,0) =  cos (delta_yaw);
  				transform_1 (0,1) =  sin (delta_yaw);
  				transform_1 (1,0) = -sin (delta_yaw);
  				transform_1 (1,1) =  cos (delta_yaw);
  				transform_1 (0,3) = -delta_y; //odom orientation is 90 degree rotated with respect to laser
  				transform_1 (1,3) = -delta_x;
  				transform_1 (2,3) = 0.0;
  				transform_1 = transform_1;
  				pcl::transformPointCloud (cost_map_cloud, cost_map_cloud, transform_1);
  			//ROS_INFO("cloud_to_costmap");
  				cloud_to_costmap(cost_map_cloud, false);
			}
						
			last_x = curr_x;
			last_y = curr_y;
			last_yaw = curr_yaw;
			if (first_loop && transform_present) 
			{
				first_loop = false;
				//ROS_INFO("start moving pc!....");	
			}
		
			// Publishing cost_map pc
			pcl::toROSMsg(cost_map_cloud,costmap_cl);
    			costmap_cl.header.frame_id = "laser";
    			costmap_cl.header.stamp = ros::Time::now();		
			cost_map_cl_pub_.publish(costmap_cl);			
			
			if (count < 40)
			   	count++;
			else
				testCallBack();
				
			//Publish trace path
			sensor_msgs::PointCloud2 path_trace; 
			pcl::toROSMsg(path_trace_pcl,path_trace);
    			path_trace.header.frame_id = "laser";
    			path_trace.header.stamp = ros::Time::now();
    			path_trace_pub_.publish(path_trace);
    			
			rate.sleep();
			ros::spinOnce ();
			
			
		}
	}
	
	
	protected:
	
		// Node Handler
		ros::NodeHandle n_;
		ros::NodeHandle* n;
		 
		// Subscribers
		ros::Subscriber SubFromCloud_;
		
		ros::Subscriber subFromTrackSpeed_;
		ros::Subscriber subFromGoal_;
		// Publishers
		ros::Publisher obstcle_pub_;
		ros::Publisher obstcle_proj_pub_;
		ros::Publisher cost_map_cl_pub_;
		ros::Publisher repuslive_force_pub_;
		ros::Publisher path_pub_;
		ros::Publisher path_solution_pub_;
		ros::Publisher path_trace_pub_;
		
		geometry_msgs::Vector3 repulsive_force;
		
		//Class Global Variables

		double normal_threshold;
		double height_threshold;
		double height_max;
		sensor_msgs::PointCloud2 output_cloud; 
		sensor_msgs::PointCloud2 cloud_obstacle_projected; 
		sensor_msgs::PointCloud2 costmap_cl;
		sensor_msgs::PointCloud2 key_cloud;

		//costmap variables
		costmap_2d::Costmap2D* master_grid_;
		double costmap_x_size;
		double costmap_y_size;
		double costmap_res;
		pcl::PointCloud<pcl::PointXYZI> cost_map_cloud;
		unsigned int cell_x;
		unsigned int cell_y;
				
		std::string global_frame, topic_name;
		costmap_2d::Costmap2DPublisher* master_grid_ros;
		
		
		float angular_resolution;
		float support_size;
		bool setUnseenToMaxRange;

		//Obstacle avoidance variables
		Vector3f nav_goal;
		bool goal_present;
		
		
		//Path finder
		pcl::PointCloud<pcl::PointXYZ> path_trace_pcl;
		float path_z_inc;
		int particle_no;
  		int iteration;
  		bool demo_;
		
		
};
int main(int argc, char **argv)
{
	ros::init(argc, argv, "pcl_analyser");
	ros::NodeHandle node;
	
	

	ObstacleDetectorClass Obstacle_rec(node);
	
	Obstacle_rec.run();
	
	return 0;
}
